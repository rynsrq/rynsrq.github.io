<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Reading Tracker (Offline Timer)</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700&display=swap" rel="stylesheet">
  <style>
    :root{
      --bg:#2f2418;
      --surface:#231a12;
      --panel:#3b3026;
      --muted:#b8a995;
      --accent:#f6c9d2; /* start peel color */
      --accent-text:#241916; /* text color on accent */
      --white:#fff6f6;
      --radius:14px;
      --safe-bottom: env(safe-area-inset-bottom, 12px);
    }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,'Helvetica Neue',Arial;background:var(--bg);color:var(--white);-webkit-font-smoothing:antialiased}
    .app{
      width:100%;
      max-width:420px;
      margin:0 auto;
      padding:14px 12px calc(120px + var(--safe-bottom));
    }
    header{display:flex;align-items:center;justify-content:space-between;margin-bottom:8px}
    header h1{font-size:20px;margin:0;font-weight:700}
    header .sub{font-size:12px;color:var(--muted)}
    .list{display:flex;flex-direction:column;gap:10px;margin-top:8px}
    .session{display:flex;align-items:center;justify-content:space-between;padding:10px 10px;border-radius:12px;min-height:48px;transition:transform .18s ease;background:linear-gradient(90deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));color:var(--white);font-size:14px}
    .session .left{display:flex;gap:10px;align-items:center}
    .session .time-s{font-weight:700;font-size:15px}
    .session .dur{font-size:13px;color:var(--muted)}
    .session .actions{display:flex;gap:8px;align-items:center}
    .btn{background:transparent;border:1px solid rgba(255,255,255,0.06);padding:8px 10px;border-radius:10px;color:var(--white);font-weight:600;font-size:13px}
    .btn.danger{border-color:rgba(255,80,80,0.3);color:#ffb8b8}
    .session.swiped{transform:translateX(-82px)}
    /* Start FAB (peel) */
    .fab{position:fixed;right:14px;bottom:120px;background:var(--accent);color:var(--accent-text);padding:12px 18px;border-radius:28px;box-shadow:0 10px 30px rgba(0,0,0,0.35);display:flex;gap:8px;align-items:center;font-weight:700;border:0;z-index:40;font-size:14px}
    .fab svg{width:18px;height:18px}
    /* MINI TODAY pill — made identical to FAB but placed on left */
    .mini-today{
      position:fixed;
      left:14px;
      bottom:120px;
      background:var(--accent);
      color:var(--accent-text);
      padding:12px 18px;
      border-radius:28px;
      box-shadow:0 10px 30px rgba(0,0,0,0.35);
      display:none;
      align-items:center;
      gap:8px;
      font-weight:700;
      z-index:40;
      font-size:14px;
    }
    .mini-today.visible{display:flex}
    /* when not running we keep same appearance (per request exact same color & size as start peel) */
    .toast{position:fixed;left:50%;transform:translateX(-50%);bottom:96px;background:#1f1a17;padding:12px 16px;border-radius:12px;display:none;align-items:center;gap:12px;box-shadow:0 8px 24px rgba(0,0,0,0.5);z-index:41}
    .toast.show{display:flex}
    .toast button{background:transparent;border:0;color:var(--accent);font-weight:700}
    .month-title{font-size:18px;margin:6px 0 8px;display:flex;align-items:center;justify-content:space-between}
    .month-title button{background:transparent;border:0;color:var(--muted);font-weight:700;padding:8px;border-radius:10px}
    .weekdays{display:flex;gap:6px;color:var(--muted);margin-bottom:8px}
    .weekdays div{flex:1;text-align:center;font-size:12px}
    .calendar-grid{display:grid;grid-template-columns:repeat(7,1fr);gap:8px}
    .circle-day{width:40px;height:40px;border-radius:50%;display:flex;align-items:center;justify-content:center;background:rgba(255,255,255,0.03);color:var(--muted);margin:auto;font-weight:700;position:relative;font-size:13px;transition:all .18s ease}
    .circle-day.today{outline:3px solid rgba(245,183,198,0.18)}
    /* session-day uses same color as start peel */
    .circle-day.has-session{
      background: var(--accent);
      color: var(--accent-text);
      box-shadow: 0 8px 20px rgba(0,0,0,0.18);
      font-weight:800;
    }
    .month-block{margin-bottom:20px}
    .month-label{font-size:18px;margin:6px 0;color:var(--white)}
    .months-row{display:flex;gap:8px;overflow:auto;padding:8px 4px}
    .month-box{min-width:86px;padding:10px;border-radius:12px;background:var(--panel);text-align:center}
    .section{background:var(--panel);padding:12px;border-radius:12px;margin-top:12px}
    .section h3{margin:0 0 10px 0;color:var(--white);font-size:15px}
    .row{display:flex;align-items:center;justify-content:space-between;padding:10px;border-radius:12px;background:rgba(255,255,255,0.02);margin-bottom:8px;font-size:14px}
    .row .label{display:flex;gap:12px;align-items:center}
    .row small{color:var(--muted)}
    .modal-overlay{position:fixed;inset:0;background:rgba(0,0,0,0.6);display:none;align-items:center;justify-content:center;padding:20px;z-index:50}
    .modal{background:var(--surface);padding:12px;border-radius:12px;max-width:420px;width:100%;max-height:80vh;overflow:auto}
    .modal h4{margin:0 0 8px}
    .modal .sess-row{display:flex;align-items:center;justify-content:space-between;padding:8px;border-radius:10px;background:rgba(255,255,255,0.02);margin-bottom:8px}
    .modal label{font-size:13px;color:var(--muted)}
    .bottom-nav{position:fixed;left:0;right:0;bottom:0;height:76px;background:#3b2f24;display:flex;gap:8px;align-items:center;justify-content:space-around;padding:12px;border-top-left-radius:12px;border-top-right-radius:12px;z-index:39}
    .nav-item{flex:1;text-align:center;color:var(--muted);font-weight:700;padding:8px;border-radius:12px}
    .nav-item.active{background:#2a2118;padding:10px;border-radius:18px;color:var(--white)}
    @media (max-width:360px){
      .app{padding:12px 10px calc(120px + var(--safe-bottom));}
      .session{padding:10px}
      header h1{font-size:18px}
      .mini-today{left:10px;bottom:120px;padding:10px 14px}
    }
  </style>
</head>
<body>
  <div class="app" id="app">
    <header>
      <div>
        <h1 id="pageTitle">Home</h1>
        <div class="sub" id="subTitle">Today</div>
      </div>
      <div class="sub" id="clock">--:--</div>
    </header>

    <!-- HOME -->
    <main id="homeView">
      <div class="list" id="sessionList"></div>
      <div id="summaryRow" style="margin-top:8px;display:flex;gap:8px">
        <div id="todayCard" style="flex:1;background:rgba(255,255,255,0.02);padding:10px;border-radius:12px;text-align:center">Today<br><strong id="sumToday">0h 0m</strong></div>
        <div style="flex:1;background:rgba(255,255,255,0.02);padding:10px;border-radius:12px;text-align:center">This Week<br><strong id="sumWeek">0h 0m</strong></div>
        <div style="flex:1;background:rgba(255,255,255,0.02);padding:10px;border-radius:12px;text-align:center">Month<br><strong id="sumMonth">0h 0m</strong></div>
      </div>
    </main>

    <!-- CALENDAR -->
    <main id="calendarView" style="display:none">
      <div class="month-block">
        <div class="month-title"><button id="prevMonth">◀</button><div id="monthTitleText">Month</div><button id="nextMonth">▶</button></div>
        <div class="weekdays"><div>M</div><div>T</div><div>W</div><div>T</div><div>F</div><div>S</div><div>S</div></div>
        <div class="calendar-grid" id="calendarGrid"></div>
      </div>
      <div class="month-block" style="margin-top:6px">
        <div class="month-label">Last 12 months</div>
        <div class="months-row" id="monthsList"></div>
      </div>
    </main>

    <!-- CONFIG -->
    <main id="configView" style="display:none">
      <div class="section">
        <h3>Storage</h3>
        <div class="row"><div><strong>Backup</strong><br><small>Export a backup file of your sessions</small></div><div><button id="exportBtn">Export</button></div></div>
        <div class="row"><div><strong>Import</strong><br><small>Load sessions from a backup JSON</small></div><div><input id="importFile" type="file" accept="application/json"></div></div>
      </div>
    </main>

    <!-- Modal for day sessions -->
    <div class="modal-overlay" id="modalOverlay">
      <div class="modal" role="dialog" aria-modal="true" id="modal">
        <h4 id="modalTitle">Sessions</h4>
        <div id="modalContent"></div>
        <div style="display:flex;gap:8px;justify-content:flex-end;margin-top:8px">
          <button class="btn" id="closeModal">Close</button>
        </div>
      </div>
    </div>

    <!-- undo toast -->
    <div class="toast" id="toast"><div id="toastText">Deleted</div><button id="undoBtn">Undo</button></div>

    <!-- Mini today's pill (hidden by default, shows when total time > 0 or running) -->
    <div id="miniToday" class="mini-today" aria-hidden="true"></div>

    <button class="fab" id="startBtn"><svg viewBox="0 0 24 24" width="18" height="18" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M5 3v18l15-9L5 3z"/></svg> Start</button>

  </div>

  <div class="bottom-nav">
    <div class="nav-item active" id="navHome">Home</div>
    <div class="nav-item" id="navCalendar">Calendar</div>
    <div class="nav-item" id="navConfig">Configurations</div>
  </div>

  <script type="module">
    // --- FIREBASE CONFIGURATION AND INITIALIZATION ---
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
    import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
    import { getFirestore, doc, getDoc, addDoc, deleteDoc, onSnapshot, collection, query, writeBatch, orderBy } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

    // PASTE YOUR CONFIG HERE (MUST BE UPDATED)
    const firebaseConfig = {
      apiKey: "AIzaSyAeTzfg4WhmuGrGwHVShDJ_oNHYW8EgBZw", 
      authDomain: "time-tracker-ff.firebaseapp.com",
      projectId: "time-tracker-ff", 
      storageBucket: "time-tracker-ff.firebasestorage.app",
      messagingSenderId: "516931076456",
      appId: "1:516931076456:web:dac05b772bcfc02bff16dd"
    };

    let app;
    let db;
    let auth;
    let userId = null;
    let isAuthReady = false;
    let sessionsCache = {}; // Local cache of all sessions

    // Firestore Path Helpers
    const getSessionsPath = () => `users/${userId}/sessions`;
    // New path for the persistent running timer state
    const getRunningStateDocRef = () => doc(db, `users/${userId}/state/runningTimer`);

    async function initFirebase() {
        try {
            app = initializeApp(firebaseConfig);
            auth = getAuth(app);
            db = getFirestore(app);

            await signInAnonymously(auth);

            onAuthStateChanged(auth, async (user) => {
                if (user) {
                    userId = user.uid;
                    isAuthReady = true;

                    // CHECK FOR OFFLINE RUNNING SESSION
                    const stateDoc = await getDoc(getRunningStateDocRef());
                    if (stateDoc.exists() && stateDoc.data().isRunning) {
                        const state = stateDoc.data();
                        // Set the application state based on the saved data
                        running = true;
                        startTs = state.startTs;
                        
                        // Update the FAB immediately and restart the display timer
                        updateFab(); 
                        timerId = setInterval(()=>{ updateFab(); renderRunningSession(); }, 300);
                        
                        // Update UI elements for running state
                        startBtn.textContent = 'Stop'; 
                        startBtn.style.background = 'var(--accent)'; 
                        startBtn.style.color = 'var(--accent-text)'; 
                        miniToday.classList.add('running');
                    }

                    // Start rendering and listening for data only after auth is ready
                    renderHome();
                    renderCalendar(currentYear, currentMonth);
                    renderMonths();
                    setupRealtimeListener();

                } else {
                    console.log("No user signed in.");
                }
            });
        } catch (error) {
            console.error("Firebase Initialization Error:", error);
            document.getElementById('sessionList').innerHTML = `<div style="color:red;padding:20px;text-align:center;">
                Error loading data. Check console for Firebase setup issues.
            </div>`;
        }
    }
    
    // --- REAL-TIME DATA LISTENER ---
    function setupRealtimeListener() {
        if (!db || !userId) return;

        const q = query(collection(db, getSessionsPath()), orderBy("start", "desc"));

        onSnapshot(q, (snapshot) => {
            sessionsCache = {};
            snapshot.docs.forEach(doc => {
                const session = doc.data();
                session.id = doc.id; // Store Firestore document ID
                const dateKey = session.dateKey; 

                if (!sessionsCache[dateKey]) {
                    sessionsCache[dateKey] = [];
                }
                sessionsCache[dateKey].push(session);
            });
            // Re-render UI based on the new data
            renderHome();
            renderCalendar(currentYear, currentMonth);
            renderMonths();
        }, (error) => {
            console.error("Error setting up real-time listener:", error);
        });
    }

    // Function to get data from cache (replaces loadData)
    function getSessionsByDate(dateKey) {
        return sessionsCache[dateKey] || [];
    }

    // --- APPLICATION LOGIC ---
    let running=false, startTs=null, timerId=null;
    const startBtn=document.getElementById('startBtn');
    const miniToday=document.getElementById('miniToday');
    const sessionList=document.getElementById('sessionList');
    const sumTodayEl=document.getElementById('sumToday');
    const sumWeekEl=document.getElementById('sumWeek');
    const sumMonthEl=document.getElementById('sumMonth');
    const calendarGrid=document.getElementById('calendarGrid');
    const monthTitleText=document.getElementById('monthTitleText');
    const monthsList=document.getElementById('monthsList');
    const summaryRow=document.getElementById('summaryRow');
    let lastDeleted = null;
    const toast=document.getElementById('toast'); const toastText=document.getElementById('toastText'); const undoBtn=document.getElementById('undoBtn');
    let toastTimer=null;

    function pad(n){ return String(n).padStart(2,'0') }
    function secsToHMS(total){ total=Math.floor(total); const h=Math.floor(total/3600); const m=Math.floor((total%3600)/60); const s=total%60; return `${pad(h)}:${pad(m)}:${pad(s)}` }
    function shortHours(total){ if(!total) return '0h 0m'; const h=Math.floor(total/3600); const m=Math.floor((total%3600)/60); return `${h}h ${m}m` }
    function fmtTime(iso){ const d=new Date(iso); return d.toLocaleTimeString([], {hour:'2-digit',minute:'2-digit'}); }

    // Saves the completed session
    async function saveSession(start, end){ 
        if (!db || !userId) return;
        const startDate=new Date(start);
        // Duration calculation MUST use the saved startTs and the current end time (Date.now())
        const secs=Math.floor((new Date(end)-new Date(start))/1000); 

        const sessionData = {
            start: startDate.toISOString(),
            end: new Date(end).toISOString(),
            dateKey: startDate.toISOString().slice(0, 10), // Used for querying/grouping
            secs: secs,
            timestamp: Date.now() // For initial sorting if needed
        };

        try {
            await addDoc(collection(db, getSessionsPath()), sessionData);
            // Note: renderHome/updateMiniVisibility called automatically by onSnapshot
        } catch (e) {
            console.error("Error adding document: ", e);
            alert("Error saving session. Check console.");
        }
    }

    // Saves the running state to Firestore for persistence
    async function saveRunningState(startTs) {
        if (!db || !userId) return;
        try {
            // Use writeBatch to ensure state update and session save are atomic, though for start it's simple
            const batch = writeBatch(db);
            batch.set(getRunningStateDocRef(), { isRunning: true, startTs: startTs });
            await batch.commit();
        } catch (e) {
            console.error("Error saving running state:", e);
            alert("Error saving running state. Check console.");
        }
    }

    // Deletes the running state from Firestore
    async function deleteRunningState() {
        if (!db || !userId) return;
        try {
            await deleteDoc(getRunningStateDocRef());
        } catch (e) {
            console.error("Error deleting running state:", e);
            // Non-critical, just log
        }
    }

    startBtn.addEventListener('click', async ()=>{
      if(!running){ 
          // --- START TIMER ---
          const now = Date.now();
          running = true; 
          startTs = now; 
          
          await saveRunningState(now); // Save persistent state

          startBtn.textContent = 'Stop'; 
          startBtn.style.background = 'var(--accent)'; 
          startBtn.style.color = 'var(--accent-text)'; 
          miniToday.classList.add('running'); 
          
          timerId = setInterval(()=>{ updateFab(); renderRunningSession(); }, 300); 
      }
      else { 
          // --- STOP TIMER ---
          const end = Date.now();
          // The duration calculation uses the persistent startTs
          
          // Clear app state
          running = false; 
          clearInterval(timerId); 
          timerId = null;

          await deleteRunningState(); // Clear persistent state

          // Save the final session using the persistent startTs
          await saveSession(startTs, end); 
          
          // Reset UI
          startTs = null;
          startBtn.textContent = 'Start'; 
          startBtn.style.background = 'var(--accent)'; 
          startBtn.style.color = 'var(--accent-text)'; 
          miniToday.classList.remove('running');
          updateFab(); // Rerender totals
      }
    });

    function calculateTotalTodaySecs(isRunning, startTimestamp) {
        const todayKey = new Date().toISOString().slice(0, 10);
        let totalSecs = (sessionsCache[todayKey] || []).reduce((a, b) => a + b.secs, 0);
        if (isRunning && startTimestamp) {
            // This is the core logic: calculate time since the persistent startTs
            totalSecs += Math.floor((Date.now() - startTimestamp) / 1000);
        }
        return totalSecs;
    }

    function updateFab(){ 
      const totalTodaySecs = calculateTotalTodaySecs(running, startTs);
      const totalHtml = shortHours(totalTodaySecs);

      // 1. Update Left Peel (Mini Today) - Always Today's Total Active Time
      miniToday.innerHTML = `<svg viewBox="0 0 24 24" width="18" height="18" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M10 8h4v8h-4z"/></svg> ${totalHtml}`;

      // 2. Update Right Peel (FAB) - Running Time or Start Button
      if(running && startTs){ 
        const secs=Math.floor((Date.now()-startTs)/1000); 
        const timeHtml = secsToHMS(secs);
        const fabHtml = `<svg viewBox="0 0 24 24" width="18" height="18" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M10 8h4v8h-4z"/></svg> ${timeHtml}`; 
        startBtn.innerHTML = fabHtml; 
      } else { 
        const html = `<svg viewBox="0 0 24 24" width="18" height="18" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M5 3v18l15-9L5 3z"/></svg> Start`; 
        startBtn.innerHTML = html; 
      }
    }

    function renderRunningSession(){ 
        if(!running || !startTs) return; 
        
        const secs=Math.floor((Date.now()-startTs)/1000); // Uses persistent startTs
        const virtual={
            start: new Date(startTs).toISOString(), // Use persistent startTs
            end: new Date().toISOString(), 
            secs: secs
        }; 
        
        const top = document.querySelector('.session.virtual'); 
        if(top){ 
            const span = top.querySelector('.time-s'); 
            span.textContent = fmtTime(virtual.start); 
            const dur = top.querySelector('.dur'); 
            dur.textContent = `── ${Math.round(virtual.secs/60)} min ──`; 
            const right = top.querySelector('.right'); 
            right.textContent = fmtTime(virtual.end); 
        } 
    }

    function renderHome(){ 
      if (!isAuthReady) return; 

      const todayKey=new Date().toISOString().slice(0,10); 
      const arr = getSessionsByDate(todayKey).sort((a, b) => new Date(b.start) - new Date(a.start));

      sessionList.innerHTML='';

      if(running && startTs){ 
        // This is where the virtual running session is added
        const virtual=document.createElement('div'); 
        virtual.className='session virtual'; 
        virtual.innerHTML=`<div class="left"><div class="time-s">${fmtTime(new Date(startTs).toISOString())}</div><div class="dur">── 0 min ──</div></div><div class="actions"></div><div class="right">${fmtTime(new Date().toISOString())}</div>`; 
        sessionList.appendChild(virtual); 
        attachSwipeHandlers(virtual, null, null); 
      }

      arr.forEach((s)=>{
        const el=document.createElement('div'); 
        el.className='session';
        el.dataset.id = s.id; 
        el.dataset.date = todayKey;
        el.innerHTML = `<div class="left"><div class="time-s">${fmtTime(s.start)}</div><div class="dur">── ${Math.round(s.secs/60)} min ──</div></div><div class="actions"></div><div class="right">${fmtTime(s.end)}</div>`;
        sessionList.appendChild(el);
        attachSwipeHandlers(el, todayKey, s.id);
      });

      // Calculate Summary Totals from Cache
      const todaySecs = (sessionsCache[todayKey] || []).reduce((a,b)=>a + b.secs,0); 
      sumTodayEl.textContent = shortHours(todaySecs);
      
      const startW = startOfWeek(new Date()); 
      let weekSecs=0; 
      for(let i=0;i<7;i++){ 
          const d=new Date(startW); d.setDate(startW.getDate()+i); 
          const key=d.toISOString().slice(0,10); 
          (sessionsCache[key]||[]).forEach(s=>weekSecs+=s.secs); 
      } 
      sumWeekEl.textContent = shortHours(weekSecs);
      
      const now=new Date(); 
      const y=now.getFullYear(), m=now.getMonth(); 
      let monthSecs=0; 
      Object.keys(sessionsCache).forEach(key => {
          const date = new Date(key);
          if (date.getFullYear() === y && date.getMonth() === m) {
              sessionsCache[key].forEach(s => monthSecs += s.secs);
          }
      });
      sumMonthEl.textContent = shortHours(monthSecs);

      updateFab();
      updateMiniVisibility();
    }

    function attachSwipeHandlers(el, dateKey, docId){ 
        let startX=0, startY=0, moved=false; 
        el.addEventListener('touchstart', (e)=>{ 
            startX=e.touches[0].clientX; 
            startY=e.touches[0].clientY; 
            moved=false; 
        }, {passive:true});
        
        el.addEventListener('touchmove', (e)=>{ 
            const dx=e.touches[0].clientX - startX; 
            const dy=e.touches[0].clientY - startY; 
            if(Math.abs(dy)>30) return; 
            if(dx<0){ 
                moved=true; 
                el.style.transform = `translateX(${dx}px)`; 
            } 
        }, {passive:true});
        
        el.addEventListener('touchend', (e)=>{ 
            if(!moved) { 
                el.style.transform=''; 
                return;
            } 
            const dxEnd = parseFloat((el.style.transform||'translateX(0px)').replace(/translateX\(|px\)/g,'')) || 0; 
            
            if(dxEnd < -70){ 
                if(docId){
                    deleteSessionWithUndo(docId);
                } else if(running) { 
                    // Swipe left on the virtual running session acts as Stop
                    startBtn.click(); 
                } 
            } 
            el.style.transform=''; 
        }, {passive:true});
        
        let isDown=false; 
        let mouseStartX=0; 
        el.addEventListener('mousedown',(e)=>{ isDown=true; mouseStartX=e.clientX; }); 
        window.addEventListener('mousemove',(e)=>{ 
            if(!isDown) return; 
            const dx=e.clientX - mouseStartX; 
            if(dx<0) el.style.transform=`translateX(${dx}px)`; 
        }); 
        window.addEventListener('mouseup',(e)=>{ 
            if(!isDown) return; 
            isDown=false; 
            const t = el.style.transform || ''; 
            const dx = parseFloat(t.replace(/translateX\(|px\)/g,''))||0; 
            if(dx < -70){ 
                if(docId){
                    deleteSessionWithUndo(docId);
                } else if(running) {
                    startBtn.click();
                }
            } 
            el.style.transform=''; 
        }); 
    }

    async function deleteSessionWithUndo(docId){ 
        if (!db || !userId || !docId) return;

        let sessionToUndo = null;
        for (const dateKey in sessionsCache) {
            sessionToUndo = sessionsCache[dateKey].find(s => s.id === docId);
            if (sessionToUndo) break;
        }

        if (!sessionToUndo) {
            console.error("Session not found in cache for deletion.");
            return;
        }

        lastDeleted = { docId, sess: sessionToUndo };

        try {
            await deleteDoc(doc(db, getSessionsPath(), docId));
            showToast('Deleted', true);
        } catch (e) {
            console.error("Error deleting document: ", e);
            alert("Error deleting session. Check console.");
        }
    }

    undoBtn.addEventListener('click', async ()=>{ 
        if(!lastDeleted || !db || !userId) return; 
        
        const { docId, sess } = lastDeleted;
        
        const sessionData = { 
            start: sess.start,
            end: sess.end,
            dateKey: sess.dateKey,
            secs: sess.secs,
            timestamp: sess.timestamp
        };

        try {
            await addDoc(collection(db, getSessionsPath()), sessionData);
            lastDeleted=null; 
            hideToast();
        } catch (e) {
            console.error("Error undoing deletion:", e);
            alert("Error undoing deletion. Check console.");
        }
    });

    function showToast(text, showUndo=false){ toastText.textContent = text; toast.classList.add('show'); if(toastTimer) clearTimeout(toastTimer); toastTimer = setTimeout(()=>{ hideToast(); lastDeleted=null; }, 5000); }
    function hideToast(){ toast.classList.remove('show'); if(toastTimer) clearTimeout(toastTimer); toastTimer=null; }

    const modalOverlay=document.getElementById('modalOverlay'); const modalContent=document.getElementById('modalContent'); const modalTitle=document.getElementById('modalTitle'); document.getElementById('closeModal').addEventListener('click', closeModal);

function openModalForDate(dateKey){
  const arr = getSessionsByDate(dateKey);
  const total = arr.reduce((a,b)=>a + (b.secs||0),0);
  
  modalTitle.textContent = "Total Time on " + dateKey;
  const h = Math.floor(total/3600);
  const m = Math.floor((total%3600)/60);
  let html = "<div style='font-size:18px; padding:20px; text-align:center; font-weight:700; color:var(--accent)'>" + h + "h " + m + "m</div>";
  if(arr.length===0) {
    html = "<div style='padding:16px;color:var(--muted); text-align:center;'>No sessions recorded on this day.</div>";
  }
  
  modalContent.innerHTML = html;
  modalOverlay.style.display='flex';
}

    function closeModal(){ modalOverlay.style.display='none'; }

    let currentYear=(new Date()).getFullYear(), currentMonth=(new Date()).getMonth();
    function startOfWeek(d){ const dd=new Date(d); const day=dd.getDay(); const diff = dd.getDate() - day + (day===0?-6:1); dd.setDate(diff); dd.setHours(0,0,0,0); return dd }
    function sumSecondsForDate(y,m,d){ 
        const key = `${y}-${String(m+1).padStart(2,'0')}-${String(d).padStart(2,'0')}`; 
        const arr = sessionsCache[key]||[]; 
        return arr.reduce((s,sess)=>s + (sess.secs||0),0) 
    }

    function renderCalendar(year, month){ 
      if (!isAuthReady) return; 
      calendarGrid.innerHTML=''; 
      monthTitleText.textContent = new Date(year,month,1).toLocaleString(undefined,{month:'long',year:'numeric'});
      const first=new Date(year,month,1); const leading=(first.getDay()+6)%7; const daysInMonth=new Date(year,month+1,0).getDate(); const total=leading+daysInMonth; const rows=Math.ceil(total/7);
      
      for(let i=0;i<leading;i++){ const c=document.createElement('div'); calendarGrid.appendChild(c); }
      for(let d=1; d<=daysInMonth; d++){ 
        const c=document.createElement('div'); 
        const circle=document.createElement('div'); 
        circle.className='circle-day'; 
        circle.textContent=d;
        const cellDateStr = `${year}-${String(month+1).padStart(2,'0')}-${String(d).padStart(2,'0')}`;
        
        if((sessionsCache[cellDateStr] || []).length > 0) circle.classList.add('has-session');
        
        const todayStr = new Date().toISOString().slice(0,10); 
        if(cellDateStr===todayStr) circle.classList.add('today');
        
        circle.addEventListener('click', ()=>{ openModalForDate(cellDateStr); });
        c.appendChild(circle); calendarGrid.appendChild(c); 
      }
      const trailing = rows*7 - total; 
      for(let j=0;j<trailing;j++){ const c=document.createElement('div'); calendarGrid.appendChild(c); }
    }

    function updateMiniVisibility(){
      try{
        const totalTodaySecs = calculateTotalTodaySecs(running, startTs);
        const showValue = running || (totalTodaySecs > 0); 

        if(showValue){
          miniToday.classList.add('visible');
          updateFab();
        } else {
          miniToday.classList.remove('visible');
        }
      }catch(e){ console.warn('mini visibility calc failed', e); }
    }

    document.getElementById('prevMonth').addEventListener('click', ()=>{ currentMonth--; if(currentMonth<0){ currentMonth=11; currentYear--; } renderCalendar(currentYear,currentMonth); updateMiniVisibility(); });
    document.getElementById('nextMonth').addEventListener('click', ()=>{ currentMonth++; if(currentMonth>11){ currentMonth=0; currentYear++; } renderCalendar(currentYear,currentMonth); updateMiniVisibility(); });

    function renderMonths(){ 
        if (!isAuthReady) return; 
        monthsList.innerHTML=''; 
        const now = new Date();
        for(let i=0;i<=11;i++){ 
            const dt=new Date(now.getFullYear(), now.getMonth() - i, 1);
            const y=dt.getFullYear(), m=dt.getMonth(); 
            let msecs=0; 
            
            Object.keys(sessionsCache).forEach(key => {
                const date = new Date(key);
                if (date.getFullYear() === y && date.getMonth() === m) {
                    sessionsCache[key].forEach(s => msecs += s.secs);
                }
            });

            const box=document.createElement('div'); 
            box.className='month-box'; 
            box.innerHTML=`<div style="font-size:12px">${dt.toLocaleString(undefined,{month:'short',year:'numeric'})}</div><div style="font-weight:700;margin-top:6px">${shortHours(msecs)}</div>`; 
            monthsList.prepend(box); 
        } 
        updateMiniVisibility(); 
    }

    document.getElementById('exportBtn').addEventListener('click', ()=>{ 
        const data = sessionsCache; 
        const blob=new Blob([JSON.stringify(data, null, 2)], {type:'application/json'}); 
        const url=URL.createObjectURL(blob); 
        const a=document.createElement('a'); 
        a.href=url; 
        a.download='reading_sessions_firebase_export.json'; 
        a.click(); 
        URL.revokeObjectURL(url); 
    });

    document.getElementById('importFile').addEventListener('change', (e)=>{ 
        if (!db || !userId) {
             alert('Firebase not ready. Please try again.');
             return;
        }
        const f=e.target.files[0]; 
        if(!f) return; 
        const r=new FileReader(); 
        
        r.onload=async function(){ 
            try{ 
                const importedData=JSON.parse(r.result);
                const batch = writeBatch(db);
                const sessionsColRef = collection(db, getSessionsPath());

                let count = 0;
                
                for (const dateKey in importedData) {
                    importedData[dateKey].forEach(session => {
                        const sessionData = {
                            start: session.start,
                            end: session.end,
                            dateKey: dateKey,
                            secs: session.secs,
                            timestamp: Date.now() 
                        };
                        const newDocRef = doc(sessionsColRef);
                        batch.set(newDocRef, sessionData);
                        count++;
                    });
                }
                
                await batch.commit();
                alert(`Import successful! ${count} sessions added.`);
                e.target.value = null; 
            }catch(err){ 
                console.error("Import Error:", err);
                alert('Invalid JSON file or import error. Check console.'); 
            } 
        }; 
        r.readAsText(f); 
    });


    const navHome=document.getElementById('navHome'), navCalendar=document.getElementById('navCalendar'), navConfig=document.getElementById('navConfig'); const homeView=document.getElementById('homeView'), calendarView=document.getElementById('calendarView'), configView=document.getElementById('configView');
    function setActive(el){ document.querySelectorAll('.nav-item').forEach(n=>n.classList.remove('active')); el.classList.add('active'); }
    navHome.addEventListener('click', ()=>{ setActive(navHome); homeView.style.display='block'; calendarView.style.display='none'; configView.style.display='none'; document.getElementById('pageTitle').textContent='Home'; updateMiniVisibility(); });
    navCalendar.addEventListener('click', ()=>{ setActive(navCalendar); homeView.style.display='none'; calendarView.style.display='block'; configView.style.display='none'; document.getElementById('pageTitle').textContent='Calendar'; renderCalendar(currentYear,currentMonth); renderMonths(); updateMiniVisibility(); });
    navConfig.addEventListener('click', ()=>{ setActive(navConfig); homeView.style.display='none'; calendarView.style.display='none'; configView.style.display='block'; document.getElementById('pageTitle').textContent='Configurations'; updateMiniVisibility(); });

    initFirebase();

    window.addEventListener('resize', updateMiniVisibility);
    setInterval(()=>{ document.getElementById('clock').textContent = new Date().toLocaleTimeString([], {hour:'2-digit',minute:'2-digit'}); updateMiniVisibility(); }, 1000);
    document.addEventListener('keydown', (e)=>{ if(e.key===' ') { e.preventDefault(); startBtn.click(); } });
  </script>
</body>
</html>

